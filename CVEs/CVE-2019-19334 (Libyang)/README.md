# CVE-2019-19334 (Libyang)

## Root Cause Analysis

A stack-based buffer overflow vulnerability existed in the file `src/parser.c`. This type of vulnerability occurs when a program writes more data to a buffer located on the stack than what is actually allocated for that buffer.

The function where this vulnerability existed is as follows:

```C
static int make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)
{
    /**
    * Reduced for space reasons.
    **/
    
    case LY_TYPE_IDENT:
    module_name = (const char *)data1;
    /* identity must always have a prefix */
    if (!strchr(*value, ':')) {
        sprintf(buf, "%s:%s", module_name, *value);
    } else {
        strcpy(buf, *value);
    }
    break;

    /**
    * Reduced for space reasons.
    **/
}
```

At line `1024` and line `1026`, the following operations were identified:

```C
sprintf(buf, "%s:%s", module_name, *value);
```

```C
strcpy(buf, *value);
```

If `buf` lacks sufficient space for `module_name`, `:` and `*value`, or if `*value` is larger than `buf`, a buffer overflow could occur, leading to memory corruption.

To resolve this issue, a validation mechanism was introduced before invoking `sprintf` and `strcpy`. The fix is as follows:

```C
static int make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)
{
    /**
    * Reduced for space reasons.
    **/
    
    if (!strchr(*value, ':')) 
    {
        LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);
        sprintf(buf, "%s:%s", module_name, *value);
    }
    else
    {
            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);
            strcpy(buf, *value);
    }

    /**
    * Reduced for space reasons.
    **/
}
```

## Installing The Vulnerable Version

1. We clone the repository:

```C
git clone https://github.com/CESNET/libyang.git Libyang
```

2. We navigate into the project directory:

```C
cd Libyang
```

3. We find the commit related to the vulnerability (using the first 7 characters of the commit ID provided above). I would like to view the 5 lines before and after the concerned commit for better context:

```C
git log --graph --oneline --all | grep -B 5 -A 5 "6980afa"
```

> \* | | | 31f6a10a6 packages BUGFIX do not build in source dir
>
> \* | | | 81d50e98a readme CHANGE included information about branches
>
> |/ / /
>
> \* | | dcde3ec4a VERSION bump to version 1.0.101
>
> \* | | 803710171 SOVERSION bump to version 1.4.1
>
> \* | | **6980afae2** parser BUGFIX long identityref default value buffer overflow
>
> \* | | f6d684ade parser BUGFIX long identity name buffer overflow
>
> \* | | 9c3ee622f VERSION bump to version 1.0.100
>
> \* | | 906f5e7e4 SOVERSION bump to version 1.4.0
>
> \* | | 222476c6d hash table CHANGE new debug category for hash table changes
>
> \* | | 8fe2bc6fb log BUGFIX memory leak


Now, we should see the commit `6980afa` for **CVE-2019-19334**.

4. We `checkout` the commit before the patch to retrieve the vulnerable version. Note that we `checkout` the `f6d684ade` commit, not the `803710171` commit, because the git graph is read vertically from bottom to top:

```C
git checkout f6d684ade
```

Eventually, we have the vulnerable version of **Libyang** before the fix for **CVE-2019-19334** was applied. Now, we are ready to dive in.
