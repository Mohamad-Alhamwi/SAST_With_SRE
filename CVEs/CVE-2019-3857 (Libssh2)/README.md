# CVE-2019-3857 (Libssh2)

## Root Cause Analysis

A heap-based buffer overflow vulnerability existed in the file `src/packet.c`. This type of vulnerability occurs when a program writes more data to a buffer located in the heap than what is actually allocated for that buffer.

The function where this vulnerability existed is as follows: 

```C
/**
* Reduced for space reasons.
**/

int _libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data, size_t datalen, int macstate)
{
	if(channelp)
	{
		/* set signal name (without SIG prefix) */
		uint32_t namelen = _libssh2_ntohu32(data + 9 + sizeof("exit-signal"));

		channelp->exit_signal = LIBSSH2_ALLOC(session, namelen + 1);

		if(!channelp->exit_signal)
        	rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC, "memory for signal name");
        else 
		{
			memcpy(channelp->exit_signal, data + 13 + sizeof("exit_signal"), namelen);
/**
* Reduced for space reasons.
**/
```

In this function, the client receives a packet from a server with an `exit_signal` message. At line 820, we have:

```C
uint32_t namelen = _libssh2_ntohu32(data + 9 + sizeof("exit-signal"));
```

Here, the client extracts the signal name length from the input parameter `data` and assigns it to an unsigned  integer variable called `namelen`. 

Then, at:

```C
channelp->exit_signal = LIBSSH2_ALLOC(session, namelen + 1);
```

it adds 1 to the length and uses it to allocate memory for the `exit_signal` message.

Finally, at: 

```C
memcpy(channelp->exit_signal, data + 13 + sizeof("exit_signal"), namelen);
```

the function copies `namelen` bytes of the signal name from the received packet `data` into the allocated memory `channelp->exit_signal`.

**The potential issue here** is that if the server sends an `exit_signal` message with a length of `UINT_MAX`, adding `1` to `namelen` at:

```C
channelp->exit_signal = LIBSSH2_ALLOC(session, namelen + 1);
```

would cause an integer overflow, resulting in an incorrect memory allocation. 

If allocation succeeds with a smaller-than-expected buffer, the `memcpy` operation at:

```C
memcpy(channelp->exit_signal, data + 13 + sizeof("exit_signal"), namelen);
```

would lead to a heap-based buffer overflow, as it copies `namelen` bytes into an improperly allocated region.

To prevent this, a check for integer overflow before allocation needs to be added. It was fixed as follows:

```C
/**
* Reduced for space reasons.
**/

int _libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data, size_t datalen, int macstate)
{
	if(channelp)
	{
		/* set signal name (without SIG prefix) */
		uint32_t namelen = _libssh2_ntohu32(data + 9 + sizeof("exit-signal"));

		if(namelen <= UINT_MAX - 1)
		{
            channelp->exit_signal = LIBSSH2_ALLOC(session, namelen + 1);
        }
        else
		{
            channelp->exit_signal = NULL;
        }

		if(!channelp->exit_signal)
        	rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC, "memory for signal name");
        else 
		{
			memcpy(channelp->exit_signal, data + 13 + sizeof("exit_signal"), namelen);
/**
* Reduced for space reasons.
**/
```

## Installing The Vulnerable Version

1. We clone the repository:

```C
git clone https://github.com/libssh2/libssh2.git Libssh2
```

2. We navigate into the project directory:

```C
cd Libssh2
```

3. We find the commit related to the vulnerability (using the first 7 characters of the commit ID provided above). I would like to view the 5 lines before and after the concerned commit for better context:

```C
git log --graph --oneline --all | grep -B 5 -A 5 "dc109a7"
```

> \* | | cd6c353d userauth: fix "Function call argument is an uninitialized value" (#318)
>
> \* | | 2599e2eb fixed unsigned/signed issue
>
> \* | | 4d66f676 session_disconnect: clear state
>
> \* | | 6394c0db Release notes from 1.8.1
>
> |/ /
>
> \* | **dc109a7f** Security fixes (#315)
>
> \* | e1d9bd49 fixed type warnings (#309)
>
> \* | bc00a288 Bumping version number for pending 1.8.1 release
>
> \* | 3f927a84 _libssh2_string_buf_free: use correct free (#304)
>
> \* | 3c1ff8a0 Fix for building against libreSSL #302
>
> \* | ca06fe21 Fix for when building against LibreSSL #302

Now, we should see the commit `dc109a7` for **CVE-2019-3857**.

4. We `checkout` the commit before the patch to retrieve the vulnerable version. Note that we `checkout` the `e1d9bd49` commit, not the `6394c0db` commit, because the git graph is read vertically from bottom to top:

```C
git checkout e1d9bd49
```

Eventually, we have the vulnerable version of **Libssh2** before the fix for **CVE-2019-3857** was applied. Now, we are ready to dive in.
